// Copyright 2023 kingu.dev. All rights reserved.
// Autogenerated from Pigeon (v10.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum BeaconType: Int {
  case iBeacon = 0
}

/// Generated class from Pigeon that represents data sent in messages.
struct WiFi {
  /// A timestamp representing when the beacon was observed.
  /// ISO 8601 formatted string
  var timestamp: String
  /// The network name.
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#SSID
  var ssid: String
  /// The address of the access point.
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#BSSID
  var bssid: String
  /// The detected signal level in dBm, also known as the RSSI.
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#level
  var rssi: Int64
  /// The center frequency of the primary 20 MHz frequency (in MHz) of the channel over which the client is communicating with the access point.
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#frequency
  var frequency: Int64
  /// Describes the authentication, key management, and encryption schemes supported by the access point.
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#capabilities
  var capabilities: String
  /// Not used if the AP bandwidth is 20 MHz If the AP use 40, 80, 160 or 320MHz, this is the center frequency (in MHz) if the AP use 80 + 80 MHz, this is the center frequency of the first segment (in MHz)
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#centerFreq0
  var centerFreq0: Int64
  /// Only used if the AP bandwidth is 80 + 80 MHz if the AP use 80 + 80 MHz, this is the center frequency of the second segment (in MHz)
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#centerFreq1
  var centerFreq1: Int64
  /// AP Channel bandwidth
  ///
  /// https://developer.android.com/reference/android/net/wifi/ScanResult#channelWidth
  var channelWidth: Int64

  static func fromList(_ list: [Any?]) -> WiFi? {
    let timestamp = list[0] as! String
    let ssid = list[1] as! String
    let bssid = list[2] as! String
    let rssi = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let frequency = list[4] is Int64 ? list[4] as! Int64 : Int64(list[4] as! Int32)
    let capabilities = list[5] as! String
    let centerFreq0 = list[6] is Int64 ? list[6] as! Int64 : Int64(list[6] as! Int32)
    let centerFreq1 = list[7] is Int64 ? list[7] as! Int64 : Int64(list[7] as! Int32)
    let channelWidth = list[8] is Int64 ? list[8] as! Int64 : Int64(list[8] as! Int32)

    return WiFi(
      timestamp: timestamp,
      ssid: ssid,
      bssid: bssid,
      rssi: rssi,
      frequency: frequency,
      capabilities: capabilities,
      centerFreq0: centerFreq0,
      centerFreq1: centerFreq1,
      channelWidth: channelWidth
    )
  }
  func toList() -> [Any?] {
    return [
      timestamp,
      ssid,
      bssid,
      rssi,
      frequency,
      capabilities,
      centerFreq0,
      centerFreq1,
      channelWidth,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct Beacon {
  /// The UUID that the observed beacon transmitted.
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clbeacon/3183017-uuid
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getId1()
  var uuid: String
  /// The major value that the observed beacon transmitted.
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clbeacon/1621418-major
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getId2()
  var major: Int64
  /// The minor value that the observed beacon transmitted.
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clbeacon/1621558-minor
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getId3()
  var minor: Int64
  /// The received signal strength of the beacon, measured in decibels.
  /// May be 0 for some reason. It is a specification of Core Location.
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clbeacon/1621557-rssi
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getRssi()
  var rssi: Int64
  /// A timestamp representing when the beacon was observed.
  /// ISO 8601 formatted string
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clbeacon/3183021-timestamp
  /// for Android:
  var timestamp: String
  /// The accuracy of the proximity value, measured in meters from the beacon.
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clbeacon/1621551-accuracy
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getDistance()
  var accuracy: Double
  /// Constants that reflect the relative distance to a beacon.
  ///
  /// for iOS: https://developer.apple.com/documentation/corelocation/clproximity
  /// for Android: Always returns null.
  var proximity: Int64? = nil
  /// The received signal strength of the beacon from 1 meter away, measured in decibels.
  ///
  /// for iOS: Always returns null. beacause it cannot be obtained with Core Location.
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getTxPower()
  var txPower: Int64? = nil
  /// The Bluetooth address of the beacon.
  ///
  /// for iOS: Always returns null. beacause it cannot be obtained with Core Location.
  /// for Android: https://altbeacon.github.io/android-beacon-library/javadoc/org/altbeacon/beacon/Beacon.html#getBluetoothAddress()
  var bluetoothAddress: String? = nil
  /// The type of beacon.
  ///
  /// for iOS: Always returns [BeaconType.iBeacon].
  /// for Android: Always returns [BeaconType.iBeacon].
  var type: BeaconType

  static func fromList(_ list: [Any?]) -> Beacon? {
    let uuid = list[0] as! String
    let major = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let minor = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)
    let rssi = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let timestamp = list[4] as! String
    let accuracy = list[5] as! Double
    let proximity: Int64? = list[6] is NSNull ? nil : (list[6] is Int64? ? list[6] as! Int64? : Int64(list[6] as! Int32))
    let txPower: Int64? = list[7] is NSNull ? nil : (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))
    let bluetoothAddress: String? = nilOrValue(list[8])
    let type = BeaconType(rawValue: list[9] as! Int)!

    return Beacon(
      uuid: uuid,
      major: major,
      minor: minor,
      rssi: rssi,
      timestamp: timestamp,
      accuracy: accuracy,
      proximity: proximity,
      txPower: txPower,
      bluetoothAddress: bluetoothAddress,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      uuid,
      major,
      minor,
      rssi,
      timestamp,
      accuracy,
      proximity,
      txPower,
      bluetoothAddress,
      type.rawValue,
    ]
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol WiFiHostApi {
  func isScanThrottleEnabled() throws -> Bool
  func startScan() throws -> Bool
  func stopScan() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class WiFiHostApiSetup {
  /// The codec used by WiFiHostApi.
  /// Sets up an instance of `WiFiHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: WiFiHostApi?) {
    let isScanThrottleEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.WiFiHostApi.isScanThrottleEnabled", binaryMessenger: binaryMessenger)
    if let api = api {
      isScanThrottleEnabledChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isScanThrottleEnabled()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isScanThrottleEnabledChannel.setMessageHandler(nil)
    }
    let startScanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.WiFiHostApi.startScan", binaryMessenger: binaryMessenger)
    if let api = api {
      startScanChannel.setMessageHandler { _, reply in
        do {
          let result = try api.startScan()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startScanChannel.setMessageHandler(nil)
    }
    let stopScanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.WiFiHostApi.stopScan", binaryMessenger: binaryMessenger)
    if let api = api {
      stopScanChannel.setMessageHandler { _, reply in
        do {
          try api.stopScan()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopScanChannel.setMessageHandler(nil)
    }
  }
}
private class WiFiFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return WiFi.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class WiFiFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? WiFi {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class WiFiFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return WiFiFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return WiFiFlutterApiCodecWriter(data: data)
  }
}

class WiFiFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = WiFiFlutterApiCodec(readerWriter: WiFiFlutterApiCodecReaderWriter())
}

/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class WiFiFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return WiFiFlutterApiCodec.shared
  }
  func onEvent(results resultsArg: [WiFi], completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.WiFiFlutterApi.onEvent", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([resultsArg] as [Any?]) { _ in
      completion()
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol BeaconHostApi {
  /// start scanning beacons
  ///
  /// [uuid] is required
  /// [major] and [minor] are optional. If not specified, all majors and minors are targeted.
  func startScan(uuid: String, major: Int64?, minor: Int64?) throws -> Bool
  func stopScan() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class BeaconHostApiSetup {
  /// The codec used by BeaconHostApi.
  /// Sets up an instance of `BeaconHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: BeaconHostApi?) {
    /// start scanning beacons
    ///
    /// [uuid] is required
    /// [major] and [minor] are optional. If not specified, all majors and minors are targeted.
    let startScanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.BeaconHostApi.startScan", binaryMessenger: binaryMessenger)
    if let api = api {
      startScanChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let uuidArg = args[0] as! String
        let majorArg: Int64? = args[1] is NSNull ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        let minorArg: Int64? = args[2] is NSNull ? nil : (args[2] is Int64? ? args[2] as! Int64? : Int64(args[2] as! Int32))
        do {
          let result = try api.startScan(uuid: uuidArg, major: majorArg, minor: minorArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startScanChannel.setMessageHandler(nil)
    }
    let stopScanChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.BeaconHostApi.stopScan", binaryMessenger: binaryMessenger)
    if let api = api {
      stopScanChannel.setMessageHandler { _, reply in
        do {
          try api.stopScan()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopScanChannel.setMessageHandler(nil)
    }
  }
}
private class BeaconFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return Beacon.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class BeaconFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Beacon {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class BeaconFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return BeaconFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return BeaconFlutterApiCodecWriter(data: data)
  }
}

class BeaconFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = BeaconFlutterApiCodec(readerWriter: BeaconFlutterApiCodecReaderWriter())
}

/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class BeaconFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return BeaconFlutterApiCodec.shared
  }
  func onEvent(results resultsArg: [Beacon], completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.BeaconFlutterApi.onEvent", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([resultsArg] as [Any?]) { _ in
      completion()
    }
  }
}
